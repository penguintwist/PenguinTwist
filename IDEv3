<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python IDE - Lessons 1-10</title>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    
    <style>
        .memory-item.list {
            border-color: #64b5f6;
            background: #37474f;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            border-radius: 12px 12px 0 0;
            margin-bottom: 0;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .lesson-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        
        .python-playground {
            background: white;
            border: 2px solid #667eea;
            border-radius: 0 0 12px 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.1);
            margin-bottom: 2rem;
        }
        
        .playground-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 1.5rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .playground-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .btn-run {
            background: #28a745;
            color: white;
        }
        
        .btn-run:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        
        .btn-reset {
            background: #6c757d;
            color: white;
        }
        
        .btn-reset:hover {
            background: #545b62;
            transform: translateY(-1px);
        }
        
        .btn-debug {
            background: #6c757d;
            color: white;
        }
        
        .btn-debug:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }
        
        .btn-debug.active {
            background: #fd7e14;
            color: white;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .CodeMirror {
            height: 300px;
            font-size: 14px;
            font-family: 'Fira Code', 'Courier New', monospace;
        }
        
        .output-container {
            background: #1a1a1a;
            color: #00ff00;
            padding: 1rem;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 14px;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #333;
            min-height: 60px;
            line-height: 1.4;
        }
        
        .output-container:empty::before {
            content: "Click 'Run Code' to see your output here...";
            color: #666;
            font-style: italic;
        }
        
        .memory-tracker {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 12px;
            border-top: 1px solid #333;
            min-height: 60px;
            line-height: 1.4;
        }
        
        .memory-tracker:empty::before {
            content: "Variables will appear here when you run code...";
            color: #666;
            font-style: italic;
        }
        
        .memory-tracker-title {
            color: #81c784;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .memory-item {
            display: inline-block;
            background: #4a5568;
            border: 1px solid #81c784;
            border-radius: 6px;
            padding: 0.3rem 0.6rem;
            margin: 0.2rem;
            transition: all 0.3s ease;
        }
        
        .memory-item.boolean {
            border-color: #ffd93d;
            background: #5a5030;
        }
        
        .memory-item.new {
            animation: memoryHighlight 1s ease-in-out;
        }
        
        @keyframes memoryHighlight {
            0% { background: #4facfe; transform: scale(1); }
            50% { background: #359ff0; transform: scale(1.1); }
            100% { background: #4a5568; transform: scale(1); }
        }
        
        .loading {
            color: #ffc107;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .error {
            color: #ff6b6b;
            line-height: 1.5;
        }
        
        .success {
            color: #28a745;
            line-height: 1.5;
        }
        
        .info-panel {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }
        
        .info-panel h3 {
            color: #667eea;
            margin-bottom: 1rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }
        
        .tip {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            border-left: 4px solid #fdcb6e;
        }
        
        @media (max-width: 768px) {
            .playground-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .playground-controls {
                width: 100%;
                justify-content: flex-start;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Python IDE</h1>
            <p>Educational Python interpreter with memory tracking</p>
            <span class="lesson-badge">‚úÖ Lessons 1-10 Ready</span>
        </div>
        
        <div class="python-playground">
            <div class="playground-header">
                <span>Python Code Editor</span>
                <div class="playground-controls">
                    <button class="btn btn-run" onclick="runCode()">‚ñ∂ Run Code</button>
                    <button class="btn btn-reset" onclick="resetCode()">üîÑ Reset</button>
                    <button class="btn btn-debug" id="debugToggle" onclick="toggleDebugMode()" title="Toggle debug mode">üêõ Debug</button>
                </div>
            </div>
            <div class="editor-container">
                <textarea id="editor"># Lesson 10: Logical Operators (and, or, not)
# Try combining conditions with logical operators!

age = 16
has_permission = True
is_weekend = False

# Using 'and' - both conditions must be True
if age >= 13 and age <= 19:
    print("You are a teenager")

# Using 'or' - at least one condition must be True
if is_weekend or has_permission:
    print("You can go to the party!")

# Using 'not' - reverses the boolean value
if not is_weekend:
    print("It's a school day")

# Store boolean results in variables
is_teenager = age >= 13 and age <= 19
print("Is teenager:", is_teenager)</textarea>
            </div>
            <div class="output-container" id="output"></div>
            <div class="memory-tracker" id="memoryTracker"></div>
        </div>
    </div>
    
    <!-- CodeMirror JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    
    <script>
        let editor;
        
        const defaultCode = `# Lesson 10: Logical Operators (and, or, not)
# Try combining conditions with logical operators!

age = 16
has_permission = True
is_weekend = False

# Using 'and' - both conditions must be True
if age >= 13 and age <= 19:
    print("You are a teenager")

# Using 'or' - at least one condition must be True
if is_weekend or has_permission:
    print("You can go to the party!")

# Using 'not' - reverses the boolean value
if not is_weekend:
    print("It's a school day")

# Store boolean results in variables
is_teenager = age >= 13 and age <= 19
print("Is teenager:", is_teenager)`;

        // Enhanced Educational Python Interpreter with Lessons 1-10
        class EducationalPythonInterpreter {
            constructor(options = {}) {
                this.output = [];
                this.variables = {};
                this.debugMode = options.debug || false;
                this.ifBlockExecuted = false;
                this.currentIndentLevel = 0;
            }
            
            reset() {
                this.output = [];
                this.variables = {};
                this.ifBlockExecuted = false;
                this.currentIndentLevel = 0;
            }
            
            log(message) {
                if (this.debugMode) {
                    console.log(`[Interpreter]: ${message}`);
                }
            }
            
            executeCode(code) {
                this.reset();
                this.log('Starting execution...');
                
                const trimmedCode = code.trim();
                if (!trimmedCode) {
                    return { 
                        success: true, 
                        output: '', 
                        message: 'Please write some code to run!'
                    };
                }
                
                const lines = trimmedCode.split('\n');
                
                try {
                    let i = 0;
                    while (i < lines.length) {
                        const line = lines[i];
                        const trimmed = line.trim();
                        
                        this.log(`Processing line ${i + 1}: ${trimmed}`);
                        
                        // Skip empty lines and comments
                        if (!trimmed || trimmed.startsWith('#')) {
                            i++;
                            continue;
                        }
                        
                        // Handle if/elif/else blocks
                        if (trimmed.startsWith('if ')) {
                            i = this.handleIfBlock(lines, i);
                        }
                        // Handle regular statements
                        else if (!trimmed.startsWith('elif') && !trimmed.startsWith('else:')) {
                            this.executeLine(trimmed);
                            i++;
                        } else {
                            i++;
                        }
                    }
                    
                    return { 
                        success: true, 
                        output: this.output.join('\n'),
                        message: this.output.length === 0 ? 'Code ran successfully, but nothing was printed.' : ''
                    };
                } catch (error) {
                    return { 
                        success: false, 
                        output: this.output.join('\n'), 
                        message: error.message
                    };
                }
            }
            
            handleIfBlock(lines, startIndex) {
                let i = startIndex;
                const baseIndent = this.getIndentLevel(lines[i]);
                let blockExecuted = false;
                
                // Process if/elif/else chain
                while (i < lines.length) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    const indent = this.getIndentLevel(line);
                    
                    // Check if we're still in the same if/elif/else structure
                    if (indent < baseIndent && trimmed) {
                        break;
                    }
                    
                    if (trimmed.startsWith('if ') || trimmed.startsWith('elif ')) {
                        const condition = this.extractCondition(trimmed);
                        const result = this.evaluateCondition(condition);
                        
                        this.log(`Evaluating condition: ${condition} = ${result}`);
                        
                        if (result && !blockExecuted) {
                            i = this.executeIndentedBlock(lines, i + 1, baseIndent);
                            blockExecuted = true;
                        } else {
                            i = this.skipIndentedBlock(lines, i + 1, baseIndent);
                        }
                    } else if (trimmed === 'else:') {
                        if (!blockExecuted) {
                            i = this.executeIndentedBlock(lines, i + 1, baseIndent);
                        } else {
                            i = this.skipIndentedBlock(lines, i + 1, baseIndent);
                        }
                        blockExecuted = true;
                    } else {
                        break;
                    }
                }
                
                return i;
            }
            
            executeIndentedBlock(lines, startIndex, parentIndent) {
                let i = startIndex;
                
                while (i < lines.length) {
                    const line = lines[i];
                    const indent = this.getIndentLevel(line);
                    const trimmed = line.trim();
                    
                    if (indent <= parentIndent && trimmed) {
                        break;
                    }
                    
                    if (trimmed && !trimmed.startsWith('#')) {
                        this.executeLine(trimmed);
                    }
                    
                    i++;
                }
                
                return i;
            }
            
            skipIndentedBlock(lines, startIndex, parentIndent) {
                let i = startIndex;
                
                while (i < lines.length) {
                    const line = lines[i];
                    const indent = this.getIndentLevel(line);
                    const trimmed = line.trim();
                    
                    if (indent <= parentIndent && trimmed && 
                        !trimmed.startsWith('elif') && trimmed !== 'else:') {
                        break;
                    }
                    
                    i++;
                }
                
                return i;
            }
            
            getIndentLevel(line) {
                const match = line.match(/^(\s*)/);
                return match ? match[1].length : 0;
            }
            
            extractCondition(line) {
                const match = line.match(/^(if|elif)\s+(.+):$/);
                if (!match) {
                    throw new Error(`Invalid condition syntax: ${line}`);
                }
                return match[2];
            }
            
            evaluateCondition(condition) {
                try {
                    return this.evaluateLogicalExpression(condition);
                } catch (error) {
                    throw new Error(`Error in condition: ${condition}\n${error.message}`);
                }
            }
            
            // NEW: Evaluate logical expressions with and, or, not
            evaluateLogicalExpression(expr) {
                expr = expr.trim();
                
                // Remove outer parentheses if present
                if (expr.startsWith('(') && expr.endsWith(')')) {
                    expr = expr.slice(1, -1).trim();
                }
                
                // Handle 'or' (lowest precedence)
                const orParts = this.splitByOperator(expr, ' or ');
                if (orParts.length > 1) {
                    return orParts.some(part => this.evaluateLogicalExpression(part));
                }
                
                // Handle 'and' (higher precedence)
                const andParts = this.splitByOperator(expr, ' and ');
                if (andParts.length > 1) {
                    return andParts.every(part => this.evaluateLogicalExpression(part));
                }
                
                // Handle 'not' (highest precedence)
                if (expr.startsWith('not ')) {
                    const subExpr = expr.substring(4).trim();
                    return !this.evaluateLogicalExpression(subExpr);
                }
                
                // Evaluate comparison or boolean value
                return this.evaluateSimpleExpression(expr);
            }
            
            // NEW: Split expression by operator, respecting parentheses
            splitByOperator(expr, operator) {
                const parts = [];
                let current = '';
                let parenDepth = 0;
                let inString = false;
                let stringChar = '';
                let i = 0;
                
                while (i < expr.length) {
                    const char = expr[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                        current += char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                        current += char;
                    } else if (!inString) {
                        if (char === '(') {
                            parenDepth++;
                            current += char;
                        } else if (char === ')') {
                            parenDepth--;
                            current += char;
                        } else if (parenDepth === 0 && expr.substring(i, i + operator.length) === operator) {
                            parts.push(current.trim());
                            current = '';
                            i += operator.length - 1;
                        } else {
                            current += char;
                        }
                    } else {
                        current += char;
                    }
                    i++;
                }
                
                if (current.trim()) {
                    parts.push(current.trim());
                }
                
                return parts.length > 0 ? parts : [expr];
            }
            
            // ENHANCED: Handle boolean values and comparisons
            evaluateSimpleExpression(expr) {
                // Check for comparison operators
                const compOps = ['==', '!=', '>=', '<=', '>', '<'];
                for (const op of compOps) {
                    if (expr.includes(op)) {
                        const [left, right] = expr.split(op).map(s => s.trim());
                        const leftVal = this.evaluateValue(left);
                        const rightVal = this.evaluateValue(right);
                        
                        switch(op) {
                            case '==': return leftVal == rightVal;
                            case '!=': return leftVal != rightVal;
                            case '>=': return Number(leftVal) >= Number(rightVal);
                            case '<=': return Number(leftVal) <= Number(rightVal);
                            case '>': return Number(leftVal) > Number(rightVal);
                            case '<': return Number(leftVal) < Number(rightVal);
                        }
                    }
                }
                
                // Evaluate as a boolean value
                const value = this.evaluateValue(expr);
                return this.toBool(value);
            }
            
            // NEW: Convert to boolean using Python truthiness
            toBool(value) {
                if (value === true || value === 'True') return true;
                if (value === false || value === 'False') return false;
                if (value === null || value === undefined || value === 'None') return false;
                if (value === 0 || value === '0') return false;
                if (value === '') return false;
                return true;
            }
            
            executeLine(line) {
                // Print statement (check first to avoid confusion with = in print)
                if (line.startsWith('print(')) {
                    this.handlePrint(line);
                }
                // Input statement
                else if (line.includes('input(')) {
                    throw new Error(`'input()' function requires user interaction and cannot be simulated in this environment yet.`);
                }
                // Variable assignment (including those with comparison operators)
                else if (line.includes('=')) {
                    // Check if it's an assignment (has = but not inside a string)
                    const assignmentMatch = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$/);
                    if (assignmentMatch) {
                        this.handleAssignment(line);
                    } else {
                        throw new Error(`Invalid syntax: "${line}"`);
                    }
                }
                else if (line.trim()) {
                    throw new Error(`I don't recognize: "${line}". Use variable assignments, print statements, or if/elif/else blocks.`);
                }
            }
            
            // ENHANCED: Handle assignment with logical expressions
            handleAssignment(line) {
                const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$/);
                if (!match) {
                    throw new Error(`Invalid assignment: ${line}`);
                }
                
                const varName = match[1];
                const valueStr = match[2].trim();
                
                this.log(`Assigning ${varName} = ${valueStr}`);
                
                // Check if it's a list.pop() call
                if (valueStr.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\.pop\s*\(/)) {
                    const popMatch = valueStr.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\.pop\s*\((.*)\)$/);
                    if (popMatch) {
                        const listName = popMatch[1];
                        const indexStr = popMatch[2].trim();
                        
                        if (!this.variables.hasOwnProperty(listName)) {
                            throw new Error(`Variable '${listName}' is not defined`);
                        }
                        
                        const list = this.variables[listName];
                        if (!Array.isArray(list)) {
                            throw new Error(`'${listName}' is not a list`);
                        }
                        
                        if (list.length === 0) {
                            throw new Error(`pop from empty list`);
                        }
                        
                        let index = -1;
                        if (indexStr) {
                            index = this.evaluateValue(indexStr);
                            if (typeof index !== 'number' || !Number.isInteger(index)) {
                                throw new Error(`list indices must be integers`);
                            }
                        }
                        
                        const actualIndex = index < 0 ? list.length + index : index;
                        if (actualIndex < 0 || actualIndex >= list.length) {
                            throw new Error(`pop index out of range`);
                        }
                        
                        const poppedValue = list.splice(actualIndex, 1)[0];
                        this.variables[varName] = poppedValue;
                        this.log(`Popped ${poppedValue} from ${listName} and assigned to ${varName}`);
                    }
                }
                // Check if it's a list literal
                else if (valueStr.startsWith('[') && valueStr.endsWith(']')) {
                    this.variables[varName] = this.parseList(valueStr);
                    this.log(`Assigned list to ${varName} with ${this.variables[varName].length} elements`);
                }
                // Check if it's a logical expression
                else if (this.isLogicalExpression(valueStr)) {
                    this.variables[varName] = this.evaluateLogicalExpression(valueStr);
                    this.log(`Assigned ${varName} = ${this.variables[varName]} (boolean)`);
                }
                // Check if it's a comparison
                else if (this.isComparisonExpression(valueStr)) {
                    this.variables[varName] = this.evaluateSimpleExpression(valueStr);
                    this.log(`Assigned ${varName} = ${this.variables[varName]} (comparison)`);
                }
                // Handle other values
                else {
                    this.variables[varName] = this.evaluateValue(valueStr);
                    this.log(`Assigned ${varName} = ${this.variables[varName]}`);
                }
            }
            
            // NEW: Check if expression contains logical operators
            isLogicalExpression(expr) {
                return expr.includes(' and ') || expr.includes(' or ') || expr.startsWith('not ');
            }
            
            // NEW: Check if expression contains comparison operators
            isComparisonExpression(expr) {
                const compOps = ['==', '!=', '>=', '<=', '>', '<'];
                return compOps.some(op => expr.includes(op));
            }
            
            // ENHANCED: Evaluate values including booleans
            evaluateValue(expr) {
                expr = expr.trim();
                
                // Boolean literals
                if (expr === 'True') return true;
                if (expr === 'False') return false;
                if (expr === 'None') return null;
                
                // String literals
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                // Number literals
                if (/^-?\d+$/.test(expr)) {
                    return parseInt(expr);
                }
                if (/^-?\d+\.\d+$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                // Variables
                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(expr)) {
                    if (this.variables.hasOwnProperty(expr)) {
                        return this.variables[expr];
                    }
                    throw new Error(`Variable '${expr}' is not defined`);
                }
                
                // String concatenation
                if (expr.includes('+')) {
                    const parts = expr.split('+').map(p => p.trim());
                    const values = parts.map(p => this.evaluateValue(p));
                    
                    if (values.some(v => typeof v === 'string')) {
                        return values.map(v => String(v)).join('');
                    }
                    
                    return values.reduce((a, b) => Number(a) + Number(b), 0);
                }
                
                throw new Error(`Cannot evaluate: ${expr}`);
            }
            
            handlePrint(line) {
                const match = line.match(/print\s*\(\s*([^)]*)\s*\)/);
                if (!match) {
                    throw new Error('Invalid print format. Use: print("text") or print(variable)');
                }
                
                const content = match[1].trim();
                
                // Handle multiple arguments
                const args = this.parseArguments(content);
                const outputParts = [];
                
                for (const arg of args) {
                    const trimmedArg = arg.trim();
                    
                    if ((trimmedArg.startsWith('"') && trimmedArg.endsWith('"')) || 
                        (trimmedArg.startsWith("'") && trimmedArg.endsWith("'"))) {
                        outputParts.push(trimmedArg.slice(1, -1));
                    } else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmedArg)) {
                        if (this.variables.hasOwnProperty(trimmedArg)) {
                            const value = this.variables[trimmedArg];
                            // Format boolean values as Python would
                            if (typeof value === 'boolean') {
                                outputParts.push(value ? 'True' : 'False');
                            } else if (value === null) {
                                outputParts.push('None');
                            } else {
                                outputParts.push(value);
                            }
                        } else {
                            throw new Error(`Variable '${trimmedArg}' not defined`);
                        }
                    } else if (/^-?\d+(\.\d+)?$/.test(trimmedArg)) {
                        outputParts.push(trimmedArg);
                    } else if (trimmedArg === 'True' || trimmedArg === 'False' || trimmedArg === 'None') {
                        outputParts.push(trimmedArg);
                    } else {
                        throw new Error(`Invalid print argument: ${trimmedArg}`);
                    }
                }
                
                this.output.push(outputParts.join(' '));
            }
            
            parseArguments(content) {
                const args = [];
                let current = '';
                let inQuotes = false;
                let quoteChar = '';
                
                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    
                    if (!inQuotes && (char === '"' || char === "'")) {
                        inQuotes = true;
                        quoteChar = char;
                        current += char;
                    } else if (inQuotes && char === quoteChar) {
                        inQuotes = false;
                        current += char;
                    } else if (char === ',' && !inQuotes) {
                        if (current.trim()) {
                            args.push(current.trim());
                        }
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                if (current.trim()) {
                    args.push(current.trim());
                }
                
                return args;
            }
            
            // NEW: Parse list literals
            parseList(expr) {
                // Remove brackets
                const content = expr.slice(1, -1).trim();
                
                if (!content) {
                    return []; // Empty list
                }
                
                // Parse list elements
                const elements = [];
                let current = '';
                let inString = false;
                let stringChar = '';
                let bracketDepth = 0;
                
                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                        current += char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                        current += char;
                    } else if (!inString && char === '[') {
                        bracketDepth++;
                        current += char;
                    } else if (!inString && char === ']') {
                        bracketDepth--;
                        current += char;
                    } else if (!inString && bracketDepth === 0 && char === ',') {
                        if (current.trim()) {
                            // Parse each element
                            const trimmed = current.trim();
                            
                            // String literals
                            if ((trimmed.startsWith('"') && trimmed.endsWith('"')) || 
                                (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
                                elements.push(trimmed.slice(1, -1));
                            }
                            // Boolean literals
                            else if (trimmed === 'True') {
                                elements.push(true);
                            }
                            else if (trimmed === 'False') {
                                elements.push(false);
                            }
                            else if (trimmed === 'None') {
                                elements.push(null);
                            }
                            // Number literals
                            else if (/^-?\d+$/.test(trimmed)) {
                                elements.push(parseInt(trimmed));
                            }
                            else if (/^-?\d+\.\d+$/.test(trimmed)) {
                                elements.push(parseFloat(trimmed));
                            }
                            // Variable reference
                            else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmed)) {
                                if (this.variables.hasOwnProperty(trimmed)) {
                                    elements.push(this.variables[trimmed]);
                                } else {
                                    throw new Error(`Variable '${trimmed}' is not defined`);
                                }
                            }
                            else {
                                throw new Error(`Invalid list element: ${trimmed}`);
                            }
                        }
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                // Don't forget the last element
                if (current.trim()) {
                    const trimmed = current.trim();
                    
                    // String literals
                    if ((trimmed.startsWith('"') && trimmed.endsWith('"')) || 
                        (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
                        elements.push(trimmed.slice(1, -1));
                    }
                    // Boolean literals
                    else if (trimmed === 'True') {
                        elements.push(true);
                    }
                    else if (trimmed === 'False') {
                        elements.push(false);
                    }
                    else if (trimmed === 'None') {
                        elements.push(null);
                    }
                    // Number literals
                    else if (/^-?\d+$/.test(trimmed)) {
                        elements.push(parseInt(trimmed));
                    }
                    else if (/^-?\d+\.\d+$/.test(trimmed)) {
                        elements.push(parseFloat(trimmed));
                    }
                    // Variable reference
                    else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmed)) {
                        if (this.variables.hasOwnProperty(trimmed)) {
                            elements.push(this.variables[trimmed]);
                        } else {
                            throw new Error(`Variable '${trimmed}' is not defined`);
                        }
                    }
                    else {
                        throw new Error(`Invalid list element: ${trimmed}`);
                    }
                }
                
                this.log(`Parsed list with ${elements.length} elements`);
                return elements;
            }
            
            // ENHANCED: Display with boolean highlighting
            getVariablesDisplay() {
                if (Object.keys(this.variables).length === 0) {
                    return '';
                }
                
                const items = Object.entries(this.variables)
                    .map(([name, value]) => {
                        let displayValue;
                        let className = 'memory-item';
                        
                        if (typeof value === 'boolean') {
                            displayValue = value ? 'True' : 'False';
                            className += ' boolean';
                        } else if (value === null) {
                            displayValue = 'None';
                            className += ' boolean';
                        } else if (typeof value === 'string') {
                            displayValue = `"${value}"`;
                        } else {
                            displayValue = value;
                        }
                        
                        return `<span class="${className}">${name} = ${displayValue}</span>`;
                    })
                    .join('');
                
                return `<div class="memory-tracker-title">üì¶ Variables:</div>${items}`;
            }
        }

        const pythonInterpreter = new EducationalPythonInterpreter({ 
            debug: localStorage.getItem('debugMode') === 'true' || false 
        });

        function updateDebugButtons(isActive) {
            const buttons = document.querySelectorAll('.btn-debug');
            buttons.forEach(button => {
                if (isActive) {
                    button.classList.add('active');
                    button.innerHTML = 'üêõ Debug ON';
                } else {
                    button.classList.remove('active');
                    button.innerHTML = 'üêõ Debug';
                }
            });
        }
        
        function toggleDebugMode() {
            const newDebugState = !pythonInterpreter.debugMode;
            pythonInterpreter.debugMode = newDebugState;
            localStorage.setItem('debugMode', newDebugState);
            
            updateDebugButtons(newDebugState);
            
            const message = newDebugState 
                ? "Debug mode ON - Check browser console for execution details"
                : "Debug mode OFF - Console logging disabled";
            
            setTimeout(() => {
                const outputElement = document.getElementById('output');
                if (outputElement) {
                    const currentContent = outputElement.innerHTML;
                    outputElement.innerHTML = `<div style="color: #6c757d; font-style: italic; padding: 0.5rem; border-left: 3px solid #6c757d; margin: 0.5rem 0;">${message}</div>` + currentContent;
                    
                    setTimeout(() => {
                        outputElement.innerHTML = currentContent;
                    }, 3000);
                }
            }, 100);
        }
        
        function initializeEditor() {
            const textarea = document.getElementById('editor');
            editor = CodeMirror.fromTextArea(textarea, {
                mode: 'python',
                theme: 'monokai',
                lineNumbers: true,
                indentUnit: 4,
                indentWithTabs: false,
                lineWrapping: true,
                fontSize: '14px'
            });
            editor.setValue(defaultCode);
        }
        
        async function runCode() {
            const outputElement = document.getElementById('output');
            const memoryElement = document.getElementById('memoryTracker');
            const runButton = document.querySelector('.btn-run');
            
            try {
                runButton.disabled = true;
                runButton.textContent = "Running...";
                outputElement.innerHTML = '<div class="loading">Running your code...</div>';
                
                const code = editor.getValue();
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const result = pythonInterpreter.executeCode(code);
                
                if (!result.success) {
                    outputElement.innerHTML = `<div class="error">${result.message}</div>`;
                    memoryElement.innerHTML = pythonInterpreter.getVariablesDisplay();
                } else {
                    if (result.output) {
                        const formattedOutput = result.output.replace(/\n/g, '<br>');
                        outputElement.innerHTML = `<div class="success">${formattedOutput}</div>`;
                    } else {
                        outputElement.innerHTML = `<div class="success">${result.message}</div>`;
                    }
                    
                    memoryElement.innerHTML = pythonInterpreter.getVariablesDisplay();
                }
                
            } catch (error) {
                outputElement.innerHTML = `<div class="error">Error: ${error.message}</div>`;
                memoryElement.innerHTML = '';
            } finally {
                runButton.disabled = false;
                runButton.textContent = "‚ñ∂ Run Code";
            }
        }
        
        function resetCode() {
            editor.setValue(defaultCode);
            document.getElementById('output').innerHTML = '';
            document.getElementById('memoryTracker').innerHTML = '';
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeEditor();
            
            setTimeout(() => {
                try {
                    const debugMode = localStorage.getItem('debugMode') === 'true';
                    updateDebugButtons(debugMode);
                } catch (error) {
                    console.warn('Debug initialization failed:', error);
                }
            }, 1000);
        });
    </script>
</body>
</html>
